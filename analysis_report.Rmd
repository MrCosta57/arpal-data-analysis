---
title: "Assessing Air Quality in Lombardia, Italy through Time Series Analysis: Implications for Public Health and Policy"
subtitle: "Time Series Analysis project"
author: "Giovanni Costa - 880892"
date: "AY 2023/24"
geometry: "left=1cm,right=2cm,top=1cm,bottom=1cm"
output:
  html_document:
    toc: true
    number_sections: true
    toc_depth: 2
    toc_float:
      smooth_scroll: false
    fig_caption: yes
    theme: flatly
    highlight: pygments
    css: "assets/css/styles.css"
editor_options:
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(include = TRUE)
knitr::opts_chunk$set(echo = FALSE)
knitr::opts_chunk$set(warning = FALSE)
knitr::opts_chunk$set(message = FALSE)
knitr::opts_chunk$set(fig.align = "center")
options(digits = 4)
```

```{r environment setup, include=FALSE}
rm(list = ls())
Sys.setlocale("LC_TIME", "en_US.UTF-8")
```


# Introduction
This project aims to evaluate the air quality in Lombardia, Italy, using a comprehensive time series analysis. The data for this study will be derived from sensors located at various stations across the region, which can be accessed via the regional website.

The primary focus is to underscore the significance of air quality on public health. By analyzing the trends and patterns in air quality data over time, it's possible to identify periods of high pollution and correlate these with potential health risks. This analysis will provide valuable insights into how air quality fluctuations may impact the respiratory health of Lombardia's inhabitants.

Considering the data provided by the region, the following pollutants will be analyzed across three different stations placed in different areas:

- **Benzene** is a volatile organic compound (VOC) commonly used in the production of plastics, resins, and synthetic fibers, as well as in gasoline. It is released into the air through emissions from motor vehicles, industrial processes, and the evaporation of benzene-containing products. Exposure to benzene primarily occurs through inhalation and can lead to serious health effects, including bone marrow damage, which can cause blood disorders such as anemia and increase the risk of leukemia, a type of cancer.
- **Carbon Monoxide (CO)** is a colorless, odorless gas produced by incomplete combustion of carbon-containing fuels, such as gasoline, natural gas, oil, and wood. Major sources include motor vehicles, industrial processes, and residential heating systems. CO interferes with the body's ability to transport oxygen by binding to hemoglobin in the blood, forming carboxyhemoglobin. High levels of exposure can lead to symptoms such as headaches, dizziness, and even death due to oxygen deprivation.
- **Nitrogen Dioxide (NO₂)** is a reddish-brown gas with a sharp, biting odor. It is a significant air pollutant formed primarily from the combustion of fossil fuels in vehicles, power plants, and industrial processes. NO₂ can irritate the respiratory system, exacerbate asthma, and reduce lung function. It also contributes to the formation of ground-level ozone and fine particulate matter, which can have further adverse effects on human health and the environment.
- **Nitrogen Oxides (NOₓ)** encompass a group of gases, including nitrogen dioxide (NO₂) and nitrogen monoxide (NO), produced during combustion processes, particularly at high temperatures. Major sources include motor vehicles, power plants, and industrial facilities. NOₓ gases can cause respiratory problems, contribute to the formation of smog and acid rain, and lead to the secondary formation of fine particulate matter (PM2.5), all of which can have severe health and environmental impacts.
- **Particulate Matter 10 (PM10)** refers to airborne particles with a diameter of 10 micrometers or less. These particles can originate from a variety of sources, including construction sites, road dust, industrial emissions, and combustion processes. PM10 can be inhaled into the respiratory system, leading to health issues such as respiratory infections, lung inflammation, and aggravation of existing heart and lung diseases. Long-term exposure can decrease lung function and increase mortality from cardiovascular and respiratory diseases.

In particular, PM10 is selected for the main part of this analysis because it serves as a comprehensive indicator of particulate pollution from a wide range of sources, such as traffic emissions, industrial processes, and the secondary formation of particles from gaseous pollutants. Its direct link to adverse health effects, including respiratory and cardiovascular diseases, makes PM10 a crucial measure of air quality. Additionally, other pollutants like Benzene, CO, NO₂, and NOₓ can contribute to PM10 levels through both primary emissions and secondary reactions, making them valuable predictor variables for analyzing fluctuations in PM10 concentrations.

For this study, daily data are considered, followed by aggregation into monthly averages to facilitate a long-term analysis and provide a clearer understanding of the underlying trends. Subsequently, forecasting models will be developed using the daily data to predict air quality in the region.

```{r}
# Pre-requirements
set.seed(123) # set pseudorandom generator for reproducibility
requirements <- c("dplyr", "ggplot2", "kableExtra", "ARPALData", "imputeTS", "xts", "forecast", "TSA")
for (library_name in requirements) {
  if (!require(library_name, character.only = TRUE, exclude = if (library_name == "dplyr") c("lag", "filter") else NULL)) {
    install.packages(library_name, repos = "https://cloud.r-project.org")
    library(library_name, character.only = TRUE, exclude = if (library_name == "dplyr") c("lag", "filter") else NULL)
  }
}
lag_dplyr <- dplyr::lag
filter_dplyr <- dplyr::filter
daily_ts_freq <- 365.25
monthly_ts_freq <- 12

# Import user-defined functions
source("src/utils.R")
source("src/plotting.R")
source("src/smoothing.R")
source("src/forecasting.R")

# library(styler)
# style_file("analysis_report.Rmd")
```

# Dataset description
The air quality dataset utilized is composed of daily observations of Benzene, CO, NO2, NOx, and PM10 coming from 3 different stations placed in different positions:

1. Station 548 - Milano v.Senato refers to the metropolitan area of Milan
1. Station 571 - Bormio v.Monte Braulio is located in the mountain zone
1. Station 703 - Schivenoglia v.Malpasso is placed in the rural plain of Lombardia

The analysis covers the period from January 1, 2014, to December 31, 2023. The original air quality data, which were recorded hourly, were aggregated to daily values by calculating the mean and excluding NA values. For additional details, refer to the ARPALData library manual ^[https://cran.r-project.org/web/packages/ARPALData/index.html].

A dataset with detailed information about the monitoring stations is also available. It includes the sensor ID, the pollutant measured by each sensor, as well as the location, altitude, and the start and stop dates of station operation. Since the stations measure different pollutants, columns in the dataset with all `NA` values indicate that the station does not have sensors for measuring that particular pollutant in the air.

```{r}
# Data retrieval
start_date <- "2014-01-01"
end_date <- "2023-12-31"
date_range <- seq(from = as.Date(start_date), to = as.Date(end_date), by = 1)

# Milano v.Senato, Bormio v.Monte Braulio, Schivenoglia v. Malpasso
aq_station_ids <- c(548, 571, 703)
aq_station_names_code <- c("Station 548", "Station 571", "Station 703")
aq_station_names_short <- c("Milano v.Senato", "Bormio v.Monte Braulio", "Schivenoglia v. Malpasso")
aq_station_names_full <- c("Station 548 - Milano v.Senato", "Station 571 - Bormio v.Monte Braulio", "Station 703 - Schivenoglia v. Malpasso")
station_colors <- c("steelblue", "darkorange", "#009E73")
filtering_colors <- c("red", "blue", "green")

# pollutant: unit of measure mapping
pollutant_units <- list(
  "Benzene" = "µg/m³",
  "CO" = "mg/m³",
  "NO2" = "µg/m³",
  "NOx" = "µg/m³",
  "PM10" = "µg/m³"
)

df_aq_daily <- NULL
df_aq_stations <- NULL

if (length(list.files("data/", pattern = "*.rds")) == 0) {
  # Air quality data
  df_aq_daily <- get_ARPA_Lombardia_AQ_data(
    ID_station = aq_station_ids, Date_begin = start_date,
    Date_end = end_date, Frequency = "daily", parallel = TRUE
  )
  # Station data
  df_aq_stations <- get_ARPA_Lombardia_AQ_registry()
  # Filter stations
  df_aq_stations <- df_aq_stations[df_aq_stations$IDStation %in% aq_station_ids, ]
  # Save data
  saveRDS(df_aq_daily, "data/df_aq_daily.rds")
  saveRDS(df_aq_stations, "data/df_aq_stations.rds")
} else {
  df_aq_daily <- readRDS("data/df_aq_daily.rds")
  df_aq_stations <- readRDS("data/df_aq_stations.rds")
}
```
```{r echo=FALSE,out.width="50%", out.height="20%", fig.show='hold', fig.cap="Stations zoning information"}
# plot_zoning_map(
#  title = "ARPA Lombardia zoning",
#  line_type = 1,
#  line_size = 1,
#  xlab = "Longitude",
#  ylab = "Latitude"
# )
# plot_AQ_stations(data_aq = df_aq_stations, title = "Map of ARPA stations in Lombardy", col_points = station_colors)
knitr::include_graphics(c("assets/images/zoning.png", "assets/images/stations_map.png"))
```
```{r}
missing_dates <- check_missing_dates(df_aq_daily, start_date, end_date, "day")
print(paste("The number of missing dates in the dataset from",
  start_date, "to", end_date, "is:", length(missing_dates),
  sep = " "
))
missing_dates <- NULL
```
```{r}
df_aq_m <- df_aq_daily %>% filter_dplyr(IDStation == 548)
df_aq_b <- df_aq_daily %>% filter_dplyr(IDStation == 571)
df_aq_s <- df_aq_daily %>% filter_dplyr(IDStation == 703)

com_poll_names <- find_common_pollutants(
  df_aq_m %>% dplyr::select(-IDStation, -NameStation, -Date),
  df_aq_b %>% dplyr::select(-IDStation, -NameStation, -Date),
  df_aq_s %>% dplyr::select(-IDStation, -NameStation, -Date)
)
print(paste("Common pollutants among the stations:", paste(com_poll_names, collapse = ", ")))
```

# Data overview
## Raw data
As previously mentioned, the air quality stations dataset provides details on the locations, sensors, and their operational status. Below is the table for the station located in Milan, while similar information is available for other stations, which may monitor different types of pollutants.
```{r}
# Station 548 - Milano v.Senato
print_table_custom(
  df_aq_stations %>%
    filter_dplyr(IDStation == 548) %>%
    select(c(
      IDSensor, Pollutant, Province, City,
      Latitude, Longitude, Altitude, DateStart, DateStop
    )) %>%
    distinct() %>%
    arrange(Pollutant),
  title = paste(aq_station_names_full[1], "information")
)
```
```{r}
# Station 571 - Bormio v.Monte Braulio
# print_table_custom(df_aq_stations %>%
#  filter_dplyr(IDStation == 571) %>%
#  select(c(
#    IDSensor, Pollutant, Province, City,
#    Latitude, Longitude, Altitude, DateStart, DateStop
#  )) %>%
#  distinct() %>%
#  arrange(Pollutant), title = paste(aq_station_names_full[2], "information"))
```
```{r}
# Station 703 - Schivenoglia v. Malpasso
# print_table_custom(df_aq_stations %>%
#  filter_dplyr(IDStation == 703) %>%
#  select(c(
#    IDSensor, Pollutant, Province, City,
#    Latitude, Longitude, Altitude, DateStart, DateStop
#  )) %>%
#  distinct() %>%
#  arrange(Pollutant), title = paste(aq_station_names_full[3], "information"))
```

However, it is more insightful to focus on the air quality summary tables for the different stations. First, the number of missing values within the selected 10-year daily interval is significant, and these gaps will be addressed through imputation. Additionally, while the selected pollutants generally show a small standard deviation (based on the range between the 1st and 3rd quartiles), some pollutants, such as PM10 and NOx, exhibit maximum values that are considerably higher than the 3rd quartile. 

```{r}
print_table_custom(
  df_aq_m %>%
    select(c(-IDStation, -NameStation, -Date)),
  is_summary = TRUE, title = paste(aq_station_names_full[1], "daily data statistics"),
  highlight_rows = com_poll_names
)
```
```{r}
print_table_custom(
  df_aq_b %>%
    select(c(-IDStation, -NameStation, -Date)),
  is_summary = TRUE, title = paste(aq_station_names_full[2], "daily data statistics"),
  highlight_rows = com_poll_names
)
```
```{r}
print_table_custom(
  df_aq_s %>%
    select(c(-IDStation, -NameStation, -Date)),
  is_summary = TRUE, title = paste(aq_station_names_full[3], "daily data statistics"),
  highlight_rows = com_poll_names
)
```

The data distribution of the PM10 can be better highlighted with a boxplot: the median values of the Milan station and Schivenoglia station are quite similar and all the stations present observations very distant from the others (in particular station 703). Indeed, PM10 concentrations can be higher in rural areas compared to urban metropolitan areas for several reasons. Agricultural activities, such as harvesting and livestock operations, contribute to elevated PM10 levels by generating bioaerosols rich in plant and animal matter. Additionally, rural dust often contains higher concentrations of crustal metals, exacerbated by drier climates and open spaces. Furthermore, rural areas typically experience more stable atmospheric conditions, leading to reduced dispersion of particulates compared to the more unstable, windier conditions often found in urban environments due to intense heat islands.
```{r}
# for (i in 1:length(com_poll_names)) {
#  boxplot(
#    df_aq_daily[[com_poll_names[i]]] ~ as.factor(df_aq_daily$IDStation),
#    main = "Boxplot of common pollutants among the stations",
#    xlab = "Station ID",
#    ylab = paste0(com_poll_names[i], " (", pollutant_units[[com_poll_names[i]]], ")"),
#    col = station_colors,
#    las = 2
#  )
# }
boxplot(
  df_aq_daily[["PM10"]] ~ as.factor(df_aq_daily$IDStation),
  main = "Boxplot of PM10 among the stations",
  xlab = "Station ID",
  ylab = paste0("PM10", " (", pollutant_units[["PM10"]], ")"),
  col = station_colors,
  las = 2
)
```

Standard regulatory levels for PM10 are as follows: the **Acceptable Level** is 50 µg/m³, which can be exceeded on up to 35 days per year without health concerns. The **Information Level** is set at 200 µg/m³, triggering public notifications about potential health risks. The **Alarm Level** is 300 µg/m³, prompting immediate public health actions, such as advising vulnerable groups to limit outdoor activities. Additionally, the **Annual Average** acceptable level is 40 µg/m³, ensuring that the yearly average concentration does not exceed this value to protect public health.
Fortunately, as indicated in this table, the annual average concentration of Particulate Matter 10 remains only slightly above the limit across the years.

```{r}
aq_m_pm10_by_year <- df_aq_m %>%
  dplyr::mutate(year = format(Date, "%Y")) %>%
  dplyr::group_by(year) %>%
  dplyr::summarize(mean_value = mean(PM10, na.rm = TRUE))
aq_b_pm10_by_year <- df_aq_b %>%
  dplyr::mutate(year = format(Date, "%Y")) %>%
  dplyr::group_by(year) %>%
  dplyr::summarize(mean_value = mean(PM10, na.rm = TRUE))
aq_s_pm10_by_year <- df_aq_s %>%
  dplyr::mutate(year = format(Date, "%Y")) %>%
  dplyr::group_by(year) %>%
  dplyr::summarize(mean_value = mean(PM10, na.rm = TRUE))
aq_pm10_by_year <- cbind(aq_m_pm10_by_year, aq_b_pm10_by_year$mean_value, aq_s_pm10_by_year$mean_value)
colnames(aq_pm10_by_year) <- c("Year", aq_station_names_short)
print_table_custom(aq_pm10_by_year, title = "Mean PM10 values by year")
aq_m_pm10_by_year <- NULL
aq_b_pm10_by_year <- NULL
aq_s_pm10_by_year <- NULL
aq_pm10_by_year <- NULL
```


## Time series data
Currently, the data are analyzed as time series rather than as raw values, and further considerations will be based on this interpretation. The plot displaying time series from all stations confirms previous observations about data distribution: the Milan station generally records higher PM10 values, whereas the Bormio station reports the lowest levels, and the Schivenoglia station shows numerous peaks.

```{r}
ts_m <- xts(df_aq_m$PM10, order.by = df_aq_m$Date)
ts_b <- xts(df_aq_b$PM10, order.by = df_aq_b$Date)
ts_s <- xts(df_aq_s$PM10, order.by = df_aq_s$Date)
```
```{r fig.height=6, fig.width=10}
plot_3_ts(
  ts1 = ts_m, ts2 = ts_b, ts3 = ts_s,
  ts_colors = station_colors,
  main = "PM10 time series for the stations",
  ylab = paste("PM10 ", "(", pollutant_units[["PM10"]], ")", sep = ""),
  legend_names = aq_station_names_full
)
```

When the time series are plotted individually, their patterns become clearer. Each series exhibits variability and is evidently non-stationary, with indications of some seasonal patterns across all stations.

```{r fig.height=8, fig.width=10}
plot_ts_grid(
  ts_list = list(ts_m, ts_b, ts_s),
  ylab = paste("PM10 ", "(", pollutant_units[["PM10"]], ")", sep = ""),
  ts_colors = station_colors,
  n_row = 3,
  ts_names = aq_station_names_full
)
```
```{r}
ts_m <- xts2ts(ts_m, daily_ts_freq)
ts_b <- xts2ts(ts_b, daily_ts_freq)
ts_s <- xts2ts(ts_s, daily_ts_freq)
```

# Preprocessing
## Missing values imputation
As previously noted, the data contain many missing values, and time series require consistent spacing without gaps. The following statistics provide insight into these missing values:

- "Number of Gaps" indicates the count of NA gaps, which are sequences of one or more consecutive missing values.
- "Average Gap Size" represents the average length of these consecutive NA gaps.
- "Longest NA Gap" shows the longest sequence of consecutive missing values in the time series.
- "Most Frequent Gap Size" identifies the most commonly occurring length of missing value sequences.

```{r}
stats_na_ts_m <- imputeTS::statsNA(ts_m, print_only = FALSE)
stats_na_ts_b <- imputeTS::statsNA(ts_b, print_only = FALSE)
stats_na_ts_s <- imputeTS::statsNA(ts_s, print_only = FALSE)
stats_na_table <- as.data.frame(
  rbind(
    stats_na_ts_m,
    stats_na_ts_b,
    stats_na_ts_s
  )
)
stats_na_table <- stats_na_table[, c(-dim(stats_na_table)[2], -(dim(stats_na_table)[2] - 1))]
colnames(stats_na_table) <- c(
  "Length TS", "Number NAs", "Number Gaps", "Average Gap Size",
  "Percentage NAs", "Longest NA gap", "Most frequent gap size"
)
rownames(stats_na_table) <- aq_station_names_code
stats_na_table
```

Fortunately, the most frequent gap length is one, and the average gap size is relatively small, likely resulting from occasional sensor malfunctions. This suggests that simple imputation techniques should be reasonably accurate and close to the actual values.

```{r}
# imputeTS::ggplot_na_distribution2(ts_m,
#  title = paste(aq_station_names_code[1], "-", "missing values ratio per interval"),
# )
# imputeTS::ggplot_na_distribution2(ts_b,
#  title = paste(aq_station_names_code[2], "-", "missing values ratio per interval"),
# )
# imputeTS::ggplot_na_distribution2(ts_s,
#  title = paste(aq_station_names_code[3], "-", "missing values ratio per interval"),
# )
```

To address missing values in the time series, linear interpolation is used. This method assumes that missing values can be estimated by drawing a straight line between the known values on either side. For time series data, this means using the timestamps and values of the adjacent non-missing points to calculate the missing values.

As shown the the following plots, the values imputed among all the stations seem coherent.

```{r fig.height=4, fig.width=8}
ts_m_imputed <- imputeTS::na_interpolation(ts_m)
ts_b_imputed <- imputeTS::na_interpolation(ts_b)
ts_s_imputed <- imputeTS::na_interpolation(ts_s)

imputeTS::ggplot_na_imputations(
  window_ts_xts(ts_m, df_aq_m$Date, "2021-01-01", "2022-12-31"),
  window_ts_xts(ts_m_imputed, df_aq_m$Date, "2021-01-01", "2022-12-31"),
  title = paste(aq_station_names_short[1], "-", "Linear imputation"),
  x_axis_labels = time(window_ts_xts(ts_m, df_aq_m$Date, "2021-01-01", "2022-12-31")),
  color_points = station_colors[1],
  color_lines = rgb2hex_custom(col2rgb_custom(station_colors[1], 0.6)),
  color_imputations = "red",
  ylab = paste("PM10 ", "(", pollutant_units[["PM10"]], ")", sep = "")
)
imputeTS::ggplot_na_imputations(
  window_ts_xts(ts_b, df_aq_b$Date, "2014-01-01", "2015-12-31"),
  window_ts_xts(ts_b_imputed, df_aq_b$Date, "2014-01-01", "2015-12-31"),
  title = paste(aq_station_names_short[2], "-", "Linear imputation"),
  x_axis_labels = time(window_ts_xts(ts_b, df_aq_b$Date, "2014-01-01", "2015-12-31")),
  color_points = station_colors[2],
  color_lines = rgb2hex_custom(col2rgb_custom(station_colors[2], 0.6)),
  color_imputations = "red",
  ylab = paste("PM10 ", "(", pollutant_units[["PM10"]], ")", sep = "")
)
imputeTS::ggplot_na_imputations(
  window_ts_xts(ts_s, df_aq_s$Date, "2016-01-01", "2017-12-31"),
  window_ts_xts(ts_s_imputed, df_aq_s$Date, "2016-01-01", "2017-12-31"),
  title = paste(aq_station_names_short[3], "-", "Linear imputation"),
  x_axis_labels = time(window_ts_xts(ts_s, df_aq_s$Date, "2016-01-01", "2017-12-31")),
  color_points = station_colors[3],
  color_lines = rgb2hex_custom(col2rgb_custom(station_colors[3], 0.6)),
  color_imputations = "red",
  ylab = paste("PM10 ", "(", pollutant_units[["PM10"]], ")", sep = "")
)
ts_m <- ts_m_imputed
ts_b <- ts_b_imputed
ts_s <- ts_s_imputed
df_aq_m$PM10 <- as.numeric(ts_m_imputed)
df_aq_b$PM10 <- as.numeric(ts_b_imputed)
df_aq_s$PM10 <- as.numeric(ts_s_imputed)
```
```{r}
print(
  paste(
    "Number of NA values in PM10 among the station are: ",
    sum(
      sum(is.na(df_aq_m$PM10)),
      sum(is.na(df_aq_m$PM10)),
      sum(is.na(df_aq_b$PM10))
    )
  )
)
```

## Outliers detection
The previously identified outliers are also evident in the time series data, particularly as prominent peaks at the stations. These outliers have been left unaltered to preserve the integrity and semantics of the data.

```{r}
outliers_ts_m <- tsoutliers(ts_m)
outliers_ts_b <- tsoutliers(ts_b)
outliers_ts_s <- tsoutliers(ts_s)

tmp_ts_m <- ts(ts_m)
tmp_ts_m[outliers_ts_m$index] <- NA
imputeTS::ggplot_na_imputations(
  tmp_ts_m, ts_m,
  title = paste(aq_station_names_code[1], "-", "outliers detection"),
  x_axis_labels = date_range,
  color_lines = station_colors[1],
  color_imputations = "red",
  ylab = paste("PM10 ", "(", pollutant_units[["PM10"]], ")", sep = ""),
  size_points = NA,
  size_imputations = 3,
  legend = FALSE
)
tmp_ts_b <- ts(ts_b)
tmp_ts_b[outliers_ts_b$index] <- NA
imputeTS::ggplot_na_imputations(
  tmp_ts_b, ts_b,
  title = paste(aq_station_names_code[2], "-", "outliers detection"),
  x_axis_labels = date_range,
  color_lines = station_colors[2],
  color_imputations = "red",
  ylab = paste("PM10 ", "(", pollutant_units[["PM10"]], ")", sep = ""),
  size_points = NA,
  size_imputations = 3,
  legend = FALSE
)
tmp_ts_s <- ts(ts_s)
tmp_ts_s[outliers_ts_s$index] <- NA
imputeTS::ggplot_na_imputations(
  tmp_ts_s, ts_s,
  title = paste(aq_station_names_code[3], "-", "outliers detection"),
  x_axis_labels = date_range,
  color_lines = station_colors[3],
  color_imputations = "red",
  ylab = paste("PM10 ", "(", pollutant_units[["PM10"]], ")", sep = ""),
  size_points = NA,
  size_imputations = 3,
  legend = FALSE
)
outliers_ts_m <- NULL
outliers_ts_b <- NULL
outliers_ts_s <- NULL
tmp_ts_m <- NULL
tmp_ts_b <- NULL
tmp_ts_s <- NULL
```

# Time series data analysis
In this section data daily data are averaged across the months for performing a long-term analysis. Due to the lower number of observations, now the time series appear more clear. The time series are evidently not stationary however, just by plotting the monthly values, the trend and the seasonal pattern don't emerge much.

```{r}
agg_df_aq_m <- ARPALData::Time_aggregate(
  df_aq_m, "monthly",
  Var_vec = "PM10", Fns_vec = "mean"
)
agg_df_aq_b <- ARPALData::Time_aggregate(
  df_aq_b, "monthly",
  Var_vec = "PM10", Fns_vec = "mean"
)
agg_df_aq_s <- ARPALData::Time_aggregate(
  df_aq_s, "monthly",
  Var_vec = "PM10", Fns_vec = "mean"
)
ts_m_monthly <- xts(agg_df_aq_m$PM10, order.by = agg_df_aq_m$Date)
ts_b_monthly <- xts(agg_df_aq_b$PM10, order.by = agg_df_aq_b$Date)
ts_s_monthly <- xts(agg_df_aq_s$PM10, order.by = agg_df_aq_s$Date)

plot_ts_grid(
  ts_list = list(ts_m_monthly, ts_b_monthly, ts_s_monthly),
  ylab = paste("PM10 ", "(", pollutant_units[["PM10"]], ")", sep = ""),
  ts_colors = station_colors,
  n_row = 3,
  ts_names = aq_station_names_full
)

agg_df_aq_m <- NULL
agg_df_aq_b <- NULL
agg_df_aq_s <- NULL
ts_m_monthly <- xts2ts(ts_m_monthly, monthly_ts_freq)
ts_b_monthly <- xts2ts(ts_b_monthly, monthly_ts_freq)
ts_s_monthly <- xts2ts(ts_s_monthly, monthly_ts_freq)
```

## Autocorrelation and partial autocorrelation
Autocorrelation (ACF) and partial autocorrelation (PACF) function plots provide additional insights into the data. The ACF plots reveal a sinusoidal pattern across all stations, with a pronounced peak every six lags, suggesting a recurring pattern approximately every six months. The PACF plots also show spikes around this period, indicating the presence of significant information during these intervals. Additionally, the analysis confirms with reasonable confidence that the time series is non-stationary.

```{r}
plot_acf_pacf(ts_m_monthly, aq_station_names_code[1])
```
```{r}
plot_acf_pacf(ts_b_monthly, aq_station_names_code[2])
```
```{r}
plot_acf_pacf(ts_s_monthly, aq_station_names_code[3])
```

## Monthplot
The monthplot function is a helpful tool for visualizing and analyzing the monthly patterns in a time series. It displays the average values for each month, making it easier to identify any seasonal trends.
The resulting graph confirms the expected pattern: the observations show a pronounced monthly seasonality, with higher values typically occurring during the winter months and lower values during the summer. Additionally, the variability throughout the year is significant across all stations, indicating that the seasonal fluctuations are consistent yet varied in magnitude.

```{r}
monthplot(
  ts_m_monthly,
  main = paste("Monthly plot of PM10 for", aq_station_names_short[1]),
  xlab = "Month",
  ylab = paste("PM10 ", "(", pollutant_units[["PM10"]], ")", sep = "")
)
monthplot(
  ts_b_monthly,
  main = paste("Monthly plot of PM10 for", aq_station_names_short[2]),
  xlab = "Month",
  ylab = paste("PM10 ", "(", pollutant_units[["PM10"]], ")", sep = "")
)
monthplot(
  ts_s_monthly,
  main = paste("Monthly plot of PM10 for", aq_station_names_short[3]),
  xlab = "Month",
  ylab = paste("PM10 ", "(", pollutant_units[["PM10"]], ")", sep = "")
)
```

## Smoothing and decomposition
To better understand the trend component of the time series, this section employs smoothing techniques to estimate the underlying trend. Later, the time series from different stations will be decomposed using Seasonal and Trend decomposition using Loess (STL) to further isolate and highlight the trend, seasonal, and residual components.

A widely used and straightforward method for smoothing is the **simple moving average** filter, which computes the arithmetic mean over a centered time window of size \(2p + 1\). The filtered trend estimate at time \(t\) is given by:
$$
\hat{f}_t = \frac{1}{2p + 1} \sum_{i=-p}^p y_{t+i}
$$
The choice of the window size \(p\) is crucial as it directly influences the degree of smoothing: larger values of \(p\) result in a smoother trend, while smaller values retain more of the original variability. Various values of \(p\) are tested to explore different levels of smoothing, each with a specific purpose:

- **\(p = 3\):** A smaller window that applies minimal smoothing, allowing short-term fluctuations to be visible while still reducing noise.
- **\(p = 6\):** This value is chosen to remove the seasonal effect identified in the Auto-Correlation Function (ACF), particularly smoothing out variations that span over a half-year period.
- **\(p = 12\):** A larger window size aimed at providing more significant smoothing, potentially eliminating yearly patterns and offering a clearer view of long-term trends.

In addition, a moving average filter for the seasonal data is tried to estimate the trend, given that the monthly time series exhibits a significant seasonal component.

```{r}
plot_filtered_ts(
  original_ts = ts_m_monthly,
  filtered_ts_list = list(simple_ma(ts_m_monthly, p = 3), simple_ma(ts_m_monthly, p = 6), simple_ma(ts_m_monthly, p = 12)),
  main = paste(aq_station_names_code[1], "-", "simple moving average filter"),
  ylab = paste("PM10 ", "(", pollutant_units[["PM10"]], ")", sep = ""),
  legend_names = c("p = 3", "p = 6", "p = 12"),
  line_colors = filtering_colors
)
plot_filtered_ts(
  original_ts = ts_m_monthly,
  filtered_ts_list = list(ma_for_seasonal(ts_m_monthly, monthly_ts_freq)),
  main = paste(aq_station_names_code[1], "-", "moving average for seasonal data"),
  ylab = paste("PM10 ", "(", pollutant_units[["PM10"]], ")", sep = ""),
  legend_names = c("MA seasonal"),
  line_colors = filtering_colors
)
```
```{r}
plot_filtered_ts(
  original_ts = ts_b_monthly,
  filtered_ts_list = list(simple_ma(ts_b_monthly, p = 3), simple_ma(ts_b_monthly, p = 6), simple_ma(ts_b_monthly, p = 12)),
  main = paste(aq_station_names_code[2], "-", "simple moving average filter"),
  ylab = paste("PM10 ", "(", pollutant_units[["PM10"]], ")", sep = ""),
  legend_names = c("p = 3", "p = 6", "p = 12"),
  line_colors = filtering_colors
)
plot_filtered_ts(
  original_ts = ts_b_monthly,
  filtered_ts_list = list(ma_for_seasonal(ts_b_monthly, monthly_ts_freq)),
  main = paste(aq_station_names_code[2], "-", "moving average for seasonal data"),
  ylab = paste("PM10 ", "(", pollutant_units[["PM10"]], ")", sep = ""),
  legend_names = c("MA seasonal"),
  line_colors = filtering_colors
)
```
```{r}
plot_filtered_ts(
  original_ts = ts_s_monthly,
  filtered_ts_list = list(simple_ma(ts_s_monthly, p = 3), simple_ma(ts_s_monthly, p = 6), simple_ma(ts_s_monthly, p = 12)),
  main = paste(aq_station_names_code[3], "-", "simple moving average filter"),
  ylab = paste("PM10 ", "(", pollutant_units[["PM10"]], ")", sep = ""),
  legend_names = c("p = 3", "p = 6", "p = 12"),
  line_colors = filtering_colors
)
plot_filtered_ts(
  original_ts = ts_s_monthly,
  filtered_ts_list = list(ma_for_seasonal(ts_s_monthly, monthly_ts_freq)),
  main = paste(aq_station_names_code[3], "-", "moving average for seasonal data"),
  ylab = paste("PM10 ", "(", pollutant_units[["PM10"]], ")", sep = ""),
  legend_names = c("MA seasonal"),
  line_colors = filtering_colors
)
```

Overall, the estimated trend appears to be slowly decreasing. These data indicates also that during the COVID-19 restrictions in Italy from 2020 to 2022, the average PM10 levels did not significantly decrease. In fact, there were periods with increased PM10 values, such as at Station 571 in Bormio in 2021. This suggests that sources of particulate emissions unrelated to mobility, such as industrial activities or other local sources, played a substantial role in sustaining PM10 concentrations during this time.

To further inspect the behavior of the time series, STL (Seasonal and Trend decomposition using Loess) decomposition is applied. Given the previously observed anomalies, the robust version of the algorithm is used to mitigate their impact. STL also offers flexibility in defining the rate of change for the seasonal component. Since the seasonal pattern appears consistent over time, the seasonal window is set to "periodic" to ensure that the entire dataset is utilized for a comprehensive seasonal analysis.

```{r}
stl_ts_m_monthly <- stl(ts_m_monthly, s.window = "periodic", robust = TRUE)
stl_ts_b_monthly <- stl(ts_b_monthly, s.window = "periodic", robust = TRUE)
stl_ts_s_monthly <- stl(ts_s_monthly, s.window = "periodic", robust = TRUE)
plot(
  stl_ts_m_monthly,
  main = paste(aq_station_names_code[1], "-", "PM10 - STL decomposition")
)
plot(
  stl_ts_b_monthly,
  main = paste(aq_station_names_code[2], "-", "PM10 - STL decomposition")
)
plot(
  stl_ts_s_monthly,
  main = paste(aq_station_names_code[3], "-", "PM10 - STL decomposition")
)
```
All stations exhibit a strong seasonal component, with an overall decreasing trend. However, Station 548 shows a notable exception, as it experienced significant peaks in PM10 levels at the end of 2021 and throughout 2022.

The Ljung-Box test supports the validity of the decomposition, as it does not suggest rejecting the null hypothesis that the residuals are white noise for all stations.

```{r}
ljung_box_noise_ts_m <- Box.test(stl_ts_m_monthly$time.series[, "remainder"], type = "Ljung-Box")$p.value
ljung_box_noise_ts_b <- Box.test(stl_ts_b_monthly$time.series[, "remainder"], type = "Ljung-Box")$p.value
ljung_box_noise_ts_s <- Box.test(stl_ts_s_monthly$time.series[, "remainder"], type = "Ljung-Box")$p.value
ljung_box_noise <- data.frame(
  p_value = c(ljung_box_noise_ts_m, ljung_box_noise_ts_b, ljung_box_noise_ts_s)
)
rownames(ljung_box_noise) <- aq_station_names_code
colnames(ljung_box_noise) <- "p-value"
print_table_custom(ljung_box_noise, title = "Ljung-Box test for the noise component")

stl_ts_m_monthly <- NULL
stl_ts_b_monthly <- NULL
stl_ts_s_monthly <- NULL
ljung_box_noise_ts_m <- NULL
ljung_box_noise_ts_b <- NULL
ljung_box_noise_ts_s <- NULL
ljung_box_noise <- NULL
```
Decompositions seems white noise by statistical hypotesis test.


# Models development
As previously mentioned, this section of the analysis focuses on daily data to develop forecasting models. Given the need to predict future PM10 values for implementing preventive health measures, a short-term analysis is essential.

To simplify visualization and focus on recent data, the time series for this part of the study is limited to the period from January 1, 2022, to December 31, 2023. For an accurate evaluation, it is crucial to avoid using forecast data as training data. Therefore, the time series is divided into training and test sets, with the test period spanning from December 1, 2023, to the end of the period. A one-month test set is selected to assess how the model performs with a relatively long forecast horizon.

## ARIMA models implementation
```{r}
start_window <- "2022-01-01"
end_window <- end_date
start_window <- as.Date(start_window)
end_window <- as.Date(end_window)

# Train-test split
test_set_size <- 30
train_set_start <- start_window
train_set_end <- as.Date(end_window) - test_set_size - 1
test_set_start <- train_set_end + 1
test_set_end <- end_window
date_range_train <- seq(train_set_start, train_set_end, by = "day")
date_range_test <- seq(test_set_start, test_set_end, by = "day")
```
**Station 703 - Schivenoglia v. Malpasso**
```{r}
ts_m_train <- window_ts_xts(ts_m, df_aq_m$Date, train_set_start, train_set_end)
plot_single_ts(ts_m_train,
  ts_name = aq_station_names_code[1],
  ts_color = station_colors[1],
  ylab = paste("PM10", pollutant_units[["PM10"]])
)
plot_different_acf_pacf(ts_m_train, aq_station_names_code[1], lag_max = 40)
ts_m_train <- xts2ts(ts_m_train, daily_ts_freq)
auto_ts_m <- auto.arima(ts_m_train, ic = "aic")
checkresiduals(auto_ts_m)
```

**Station 571 - Bormio v.Monte Braulio**
```{r}
ts_b_train <- window_ts_xts(ts_b, df_aq_b$Date, train_set_start, train_set_end)
plot_single_ts(ts_b_train,
  ts_name = aq_station_names_code[2],
  ts_color = station_colors[2],
  ylab = paste("PM10", pollutant_units[["PM10"]])
)
plot_different_acf_pacf(ts_b_train, aq_station_names_code[2], lag_max = 40)
ts_b_train <- xts2ts(ts_b_train, daily_ts_freq)
auto_ts_b <- auto.arima(ts_b_train, ic = "aic")
checkresiduals(auto_ts_b)
```

**Station 703 - Schivenoglia v. Malpasso**
```{r}
ts_s_train <- window_ts_xts(ts_s, df_aq_s$Date, train_set_start, train_set_end)
plot_single_ts(ts_s_train,
  ts_name = aq_station_names_code[3],
  ts_color = station_colors[3],
  ylab = paste("PM10", pollutant_units[["PM10"]])
)
plot_different_acf_pacf(ts_s_train, aq_station_names_code[3], lag_max = 40)
ts_s_train <- xts2ts(ts_s_train, daily_ts_freq)
auto_ts_s <- auto.arima(ts_s_train, ic = "aic")
checkresiduals(auto_ts_s)
```

```{r}
# thetahat_i/SE(thetahat_i) =t_i can be used for significance test of the parameter theta_i
# H0: theta_i=0
# HA: theta_i!=0
# if |t_i| is small -> H0
# if |t_i| is large -> HA

# SIMPLE RULE FOR CHECKING THE SIGNIFICANCE:
# n large, if H0 is true t_i behaves like N(0,1)
# So if |t_i|< 2 (2 is similar to 1.96, and 1.96 is the normal distrib quantile 0.975)
#--> Accept H0 if |t_i|<=2
#--> Reject H0 if |t_i|>2

# FOR DOING IT AUTOMATICALLY:
# abs(ring.fit$coef/sqrt(diag(ring.fit$var.coef))) >2
# tsdiag(lake.fit)
# checkresiduals(lake.fit)
# fitdf<-length(fit$coef)
# Box.test(residuals(lake.fit), lag=10, fitdf=fitdf, type="Ljung")
```

## Station correlations
```{r}
# Correlation Analysis:
# Investigate the relationships between air pollutants and meteorological variables.
# Identify key factors that may contribute to poor air quality in the region.
pw <- TSA::prewhiten(diff(ts_m_train), ts_b_train, plot = FALSE)$ccf
# w <- prewhitening(ts_s_train, list(ar = auto_ts_s$model$phi, ma = auto_ts_s$model$theta))

plot(ts_b_train ~ ts_m_train)

plot_ccf_prewhiten(pw, frequency = daily_ts_freq)
# plot_ccf(u1, v1, paste(aq_station_names_code[1], "-", aq_station_names_code[2]), lag_max = 30)
# plot_ccf(u1, w1, paste(aq_station_names_code[1], "-", aq_station_names_code[3]))
# plot_ccf(v, w, paste(aq_station_names_code[2], "-", aq_station_names_code[3]))


a <- xts(df_aq_m$NO2, order.by = df_aq_m$Date)
a <- xts2ts(a, daily_ts_freq)
a <- imputeTS::na_interpolation(a)
Acf(a)
Pacf(a)


ts_no2_m_train <- window_ts_xts(a, df_aq_s$Date, train_set_start, train_set_end)
ts_no2_m_train <- xts2ts(ts_no2_m_train, daily_ts_freq)
plot(ts_m_train ~ ts_no2_m_train)
m <- lm(df_aq_m$PM10 ~ df_aq_m$NO2)
r <- resid(m)
Acf(r)
auto.arima(ts_no2_m_train, ic = "aic")

auto.arima(ts_m_train, xreg = ts_no2_m_train, ic = "aic")
```

## Dynamic regression
```{r}
# fit.y <- Arima(y, order = c(1, 0, 0))
# model.y <- list(ar = fit.y$model$phi, ma = fit.y$model$theta)
# u <- prewhitening(y, model.y)
# fit.x <- Arima(x, order = c(1, 0, 0))
# model.x <- list(ar = fit.x$model$phi, ma = fit.x$model$theta)
# v <- prewhitening(x, model.x)
# ccf(u, v, col = 4)
# grid()
```
```{r}
# try standart lin regr and multivariate TS analysis

# Correlation Analysis:
# Investigate the relationships between air pollutants and meteorological variables.
# Identify key factors that may contribute to poor air quality in the region.
```

## Non linear models
```{r}
fit <- nnetar(ts_m_train)
r <- as.numeric(resid(fit))
Acf(r, na.action = na.pass)
Box.test(r, type = "Ljung-Box") # residuals seems white noise
Acf(r^2, na.action = na.pass)
Box.test(r^2, type = "Ljung-Box")

Ccf(as.numeric(ts_m_train), r, na.action = na.pass)
Ccf(as.numeric(ts_m_train)^2, r, na.action = na.pass)
Ccf((r * as.numeric(ts_m_train)^2), r, na.action = na.pass)
```
```{r}
## For checking some threshold models
# lag1.plot(dflu, corr = FALSE, col = 4, pch = 20)
#
## Neural Network Autoregressive Model
# fit <- nnetar(y, p = 9, size = 5)
## Y_t=f(Y_{t-1}, ..., Y_{t-9})+Z_t where Z_t is WN(0, sigma^2) independent
## f(Y_{t-1}, ..., Y_{t-9}) is a NN with K=5 (5 hidden unit)
# r <- as.numeric(resid(fit))
# acf(r, na.action = na.pass)
# Box.test(r, type = "Ljung-Box") # residuals seems white noise
# acf(r^2, na.action = na.pass)
# Box.test(r^2, type = "Ljung-Box") # residuals seems white noise also if they are ^2 (check is some non lin pattern is resid^2)
# plot(forecast(fit, h = 20, times = 10, PI = TRUE, bootstrap = FALSE))
## bootstrap = FALSE: pick randomly the value e_t from Gaussian
## bootstrap=TRUE: pick error from past observation
## This is needed for the forecasting Y_t=f(X_t)+e_t
# Watt <- APTelectric[, 1]
# fit <- nnetar(Watt) # Model that use only the information coming from TS Y_t
## param p is automatically derived here because it's not specified
# nnetforecast <- forecast(fit, h = 400, PI = FALSE)
# plot(nnetforecast)
# Appliances <- as.numeric(APTelectric[, 2])
#
# fit2 <- nnetar(Watt, xreg = Appliances) # Model that use also the info of the second TS
# print(fit2)
# r <- as.numeric(resid(fit2))
# acf(r, na.action = na.pass)
# Box.test(r, type = "Ljung-Box")
# acf(r^2, na.action = na.pass)
# Box.test(r^2, type = "Ljung-Box")
#
## Check also other relations in the residuals
# par(mfrow = c(2, 2))
# ccf(Appliances, r, na.action = na.pass)
# ccf(Appliances^2, r, na.action = na.pass)
# ccf((r * Appliances^2), r, na.action = na.pass)
```
# Forecasting
```{r}
# Compare models with metrics and with "simpler" forecasting models
```


# Conclusions
```{r}
# Discussion and further perspectives.
# The discussion section should recall the main results and point to new research questions, that appeared from your work, or possible limitations.
```