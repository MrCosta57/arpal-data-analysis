---
title: "Assessing Air Quality in Lombardia, Italy through Time Series Analysis: Implications for Public Health and Policy"
subtitle: "Time Searies Analysis project"
author: "Giovanni Costa - 880892"
date: "AY 2023/24"
geometry: "left=1cm,right=2cm,top=1cm,bottom=1cm"
output:
  html_document:
    toc: true
    number_sections: true
    toc_depth: 2
    toc_float:
      smooth_scroll: false
    fig_caption: yes
    theme: flatly
    highlight: pygments
    css: "assets/css/styles.css"
editor_options:
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(include = TRUE)
knitr::opts_chunk$set(echo = FALSE)
knitr::opts_chunk$set(warning = FALSE)
knitr::opts_chunk$set(message = FALSE)
knitr::opts_chunk$set(fig.align = "center")
options(digits = 4)
```

```{r environment setup, include=FALSE}
rm(list = ls())
Sys.setlocale("LC_TIME", "en_US.UTF-8")
```


# Introduction
This project aims to evaluate the air quality in Lombardia, Italy, using a comprehensive time series analysis. The data for this study will be derived from sensors located at various stations across the region, which can be accessed via the regional website.

The primary focus is to underscore the significance of air quality on public health. By analyzing the trends and patterns in air quality data over time, it's possible to identify periods of high pollution and correlate these with potential health risks. This analysis will provide valuable insights into how air quality fluctuations may impact the respiratory health of the region's inhabitants.

In particular, the following pollutants will be analized across three different stations in Lombardia placed in different areas of the region:

Benzene
**Benzene** is a volatile organic compound (VOC) commonly used in the production of plastics, resins, and synthetic fibers, as well as in gasoline. It is released into the air through emissions from motor vehicles, industrial processes, and the evaporation of benzene-containing products. Exposure to benzene primarily occurs through inhalation and can lead to serious health effects, including bone marrow damage, which can cause blood disorders such as anemia and increase the risk of leukemia, a type of cancer.

Carbon Monoxide (CO)
**Carbon Monoxide (CO)** is a colorless, odorless gas produced by incomplete combustion of carbon-containing fuels, such as gasoline, natural gas, oil, and wood. Major sources include motor vehicles, industrial processes, and residential heating systems. CO interferes with the body's ability to transport oxygen by binding to hemoglobin in the blood, forming carboxyhemoglobin. High levels of exposure can lead to symptoms such as headaches, dizziness, and even death due to oxygen deprivation.

Nitrogen Dioxide (NO₂)
**Nitrogen Dioxide (NO₂)** is a reddish-brown gas with a sharp, biting odor. It is a significant air pollutant formed primarily from the combustion of fossil fuels in vehicles, power plants, and industrial processes. NO₂ can irritate the respiratory system, exacerbate asthma, and reduce lung function. It also contributes to the formation of ground-level ozone and fine particulate matter, which can have further adverse effects on human health and the environment.

Nitrogen Oxides (NOₓ)
**Nitrogen Oxides (NOₓ)** encompass a group of gases, including nitrogen dioxide (NO₂) and nitrogen monoxide (NO), produced during combustion processes, particularly at high temperatures. Major sources include motor vehicles, power plants, and industrial facilities. NOₓ gases can cause respiratory problems, contribute to the formation of smog and acid rain, and lead to the secondary formation of fine particulate matter (PM2.5), all of which can have severe health and environmental impacts.

Particulate Matter 10 (PM10)
**Particulate Matter 10 (PM10)** refers to airborne particles with a diameter of 10 micrometers or less. These particles can originate from a variety of sources, including construction sites, road dust, industrial emissions, and combustion processes. PM10 can be inhaled into the respiratory system, leading to health issues such as respiratory infections, lung inflammation, and aggravation of existing heart and lung diseases. Long-term exposure can decrease lung function and increase mortality from cardiovascular and respiratory diseases.

Selected PM10
Comprehensive Indicator: PM10 reflects the presence of particulate pollution from various sources, including traffic emissions, industrial processes, and secondary formation from gaseous pollutants.
Health Impact: PM10 is directly linked to adverse health effects, making it a crucial measure of air quality.
Correlations: Other pollutants (Benzene, CO, NO2, and NOx) can contribute to the levels of PM10 through primary emissions and secondary reactions, making them suitable predictor variables for analyzing variations in PM10.

Original air quality data are hourly and the pollutant are aggregated by the mean value, excluding the NA Values
The original wheter data have frequency of 10 minutes and are averaged, excluding the NA Values
More info are available on Lombardia region website

For these analysis daily data are considered, but later will be aggregated by month using mean to perform a long term analysis and understand better the components. Later model on daily data will be developed to forecast the air quality in the region.
```{r}
# Pre-requirements
set.seed(123) # set pseudorandom generator for reprocucibility
requirements <- c("dplyr", "ggplot2", "kableExtra", "ARPALData", "imputeTS", "xts", "forecast", "TSA")
for (library_name in requirements) {
  if (!require(library_name, character.only = TRUE, exclude = if (library_name == "dplyr") c("lag", "filter") else NULL)) {
    install.packages(library_name, repos = "https://cloud.r-project.org")
    library(library_name, character.only = TRUE, exclude = if (library_name == "dplyr") c("lag", "filter") else NULL)
  }
}
lag_dplyr <- dplyr::lag
filter_dplyr <- dplyr::filter
daily_ts_freq <- 365.25
monthly_ts_freq <- 12

# Import user defined functions
source("src/utils.R")
source("src/plotting.R")
source("src/smoothing.R")
source("src/forecasting.R")

# library(styler)
# style_file("analysis_report.Rmd")
```

# Dataset description
```{r}
# Data retrieval
start_date <- "2014-01-01"
end_date <- "2023-12-31"
date_range <- seq(from = as.Date(start_date), to = as.Date(end_date), by = 1)

# Milano v.Senato, Bormio v.Monte Braulio, Schivenoglia v. Malpasso
aq_station_ids <- c(548, 571, 703)
aq_station_names_code <- c("Station 548", "Station 571", "Station 703")
aq_station_names_short <- c("Milano v.Senato", "Bormio v.Monte Braulio", "Schivenoglia v. Malpasso")
aq_station_names_full <- c("Station 548 - Milano v.Senato", "Station 571 - Bormio v.Monte Braulio", "Station 703 - Schivenoglia v. Malpasso")
station_colors <- c("steelblue", "darkorange", "#009E73")
filtering_colors <- c("red", "blue", "green")

# pollutant : unit of measure mapping
pollutant_units <- list(
  "Benzene" = "µg/m³",
  "CO" = "mg/m³",
  "NO2" = "µg/m³",
  "NOx" = "µg/m³",
  "PM10" = "µg/m³"
)

df_aq_daily <- NULL
df_aq_stations <- NULL

if (length(list.files("data/", pattern = "*.rds")) == 0) {
  # Air quality data
  df_aq_daily <- get_ARPA_Lombardia_AQ_data(
    ID_station = aq_station_ids, Date_begin = start_date,
    Date_end = end_date, Frequency = "daily", parallel = TRUE
  )
  # Station data
  df_aq_stations <- get_ARPA_Lombardia_AQ_registry()
  # Filter stations
  df_aq_stations <- df_aq_stations[df_aq_stations$IDStation %in% aq_station_ids, ]
  # Save data
  saveRDS(df_aq_daily, "data/df_aq_daily.rds")
  saveRDS(df_aq_stations, "data/df_aq_stations.rds")
} else {
  df_aq_daily <- readRDS("data/df_aq_daily.rds")
  df_aq_stations <- readRDS("data/df_aq_stations.rds")
}
```

start_date <- "2014-01-01"
end_date <- "2023-12-31"
Milano v.Senato, Bormio v.Monte Braulio, Schivenoglia v. Malpasso
aq_station_ids <- c(548, 571, 703)

The stations measures different pollutants and where the columns in the dataset are all `NA` this means that the station have no sensors for measuring that pollutant in the air 

# Data overview
```{r echo=FALSE,out.width="50%", out.height="20%", fig.cap="caption", fig.show='hold'}
# plot_zoning_map(
#  title = "ARPA Lombardia zoning",
#  line_type = 1,
#  line_size = 1,
#  xlab = "Longitude",
#  ylab = "Latitude"
# )
# plot_AQ_stations(data_aq = df_aq_stations, title = "Map of ARPA stations in Lombardy", col_points = station_colors)
knitr::include_graphics(c("assets/images/zoning.png", "assets/images/stations_map.png"))
```
```{r}
print.data.frame(head(df_aq_daily, 3))
```
```{r}
print.data.frame(head(df_aq_stations, 3))
```
```{r}
missing_dates <- check_missing_dates(df_aq_daily, start_date, end_date, "day")
print(paste("The number of missing dates in the dataset from",
  start_date, "to", end_date, "is:", length(missing_dates),
  sep = " "
))
missing_dates <- NULL
```


**Common pollutants among the stations**
```{r}
df_aq_m <- df_aq_daily %>% filter_dplyr(IDStation == 548)
df_aq_b <- df_aq_daily %>% filter_dplyr(IDStation == 571)
df_aq_s <- df_aq_daily %>% filter_dplyr(IDStation == 703)

com_poll_names <- find_common_pollutants(
  df_aq_m %>% dplyr::select(-IDStation, -NameStation, -Date),
  df_aq_b %>% dplyr::select(-IDStation, -NameStation, -Date),
  df_aq_s %>% dplyr::select(-IDStation, -NameStation, -Date)
)
print(paste("Common pollutants among the stations:", paste(com_poll_names, collapse = ", ")))
```

## Raw data
Standard regulatory levels:
Acceptable Level:
50 µg/m³ (exceeded on ≤ 35 days/year).
This level is considered acceptable for public health.
Information Level:
200 µg/m³.
Exceeding this level indicates that the public should be informed about potential health risks.
Alarm Level:
300 µg/m³.
This level triggers immediate public health actions, such as advising vulnerable populations to limit outdoor activities.
Annual Average
The annual average acceptable level is set at 30 µg/m³. This means that over a year, the average concentration should not exceed this value to protect public health effectively.

**Station 548 - Milano v.Senato**
```{r}
print_table_custom(
  df_aq_stations %>%
    filter_dplyr(IDStation == 548) %>%
    select(c(
      IDSensor, Pollutant, Province, City,
      Latitude, Longitude, Altitude, DateStart, DateStop
    )) %>%
    distinct() %>%
    arrange(Pollutant),
  title = paste(aq_station_names_full[1], "information")
)
```
```{r}
print_table_custom(
  df_aq_m %>%
    select(c(-IDStation, -NameStation, -Date)),
  is_summary = TRUE, title = paste(aq_station_names_full[1], "daily data statistics"),
  highlight_rows = com_poll_names
)
```

**Station 571 - Bormio v.Monte Braulio**
```{r}
print_table_custom(df_aq_stations %>%
  filter_dplyr(IDStation == 571) %>%
  select(c(
    IDSensor, Pollutant, Province, City,
    Latitude, Longitude, Altitude, DateStart, DateStop
  )) %>%
  distinct() %>%
  arrange(Pollutant), title = paste(aq_station_names_full[2], "information"))
```
```{r}
print_table_custom(
  df_aq_b %>%
    select(c(-IDStation, -NameStation, -Date)),
  is_summary = TRUE, title = paste(aq_station_names_full[2], "daily data statistics"),
  highlight_rows = com_poll_names
)
```

**Station 703 - Schivenoglia v. Malpasso**
```{r}
print_table_custom(df_aq_stations %>%
  filter_dplyr(IDStation == 703) %>%
  select(c(
    IDSensor, Pollutant, Province, City,
    Latitude, Longitude, Altitude, DateStart, DateStop
  )) %>%
  distinct() %>%
  arrange(Pollutant), title = paste(aq_station_names_full[3], "information"))
```
```{r}
print_table_custom(
  df_aq_s %>%
    select(c(-IDStation, -NameStation, -Date)),
  is_summary = TRUE, title = paste(aq_station_names_full[3], "daily data statistics"),
  highlight_rows = com_poll_names
)
```

```{r}
aq_m_pm10_by_year <- df_aq_m %>%
  dplyr::mutate(year = format(Date, "%Y")) %>%
  dplyr::group_by(year) %>%
  dplyr::summarize(mean_value = mean(PM10, na.rm = TRUE))
aq_b_pm10_by_year <- df_aq_b %>%
  dplyr::mutate(year = format(Date, "%Y")) %>%
  dplyr::group_by(year) %>%
  dplyr::summarize(mean_value = mean(PM10, na.rm = TRUE))
aq_s_pm10_by_year <- df_aq_s %>%
  dplyr::mutate(year = format(Date, "%Y")) %>%
  dplyr::group_by(year) %>%
  dplyr::summarize(mean_value = mean(PM10, na.rm = TRUE))
aq_pm10_by_year <- cbind(aq_m_pm10_by_year, aq_b_pm10_by_year$mean_value, aq_s_pm10_by_year$mean_value)
colnames(aq_pm10_by_year) <- c("Year", aq_station_names_short)
print_table_custom(aq_pm10_by_year, title = "Mean PM10 values by year")
aq_m_pm10_by_year <- NULL
aq_b_pm10_by_year <- NULL
aq_s_pm10_by_year <- NULL
aq_pm10_by_year <- NULL
```

```{r}
for (i in 1:length(com_poll_names)) {
  boxplot(
    df_aq_daily[[com_poll_names[i]]] ~ as.factor(df_aq_daily$IDStation),
    main = "Boxplot of common pollutants among the stations",
    xlab = "Station ID",
    ylab = paste0(com_poll_names[i], " (", pollutant_units[[com_poll_names[i]]], ")"),
    col = station_colors,
    las = 2
  )
}
```


## Time series data
```{r}
ts_m <- xts(df_aq_m$PM10, order.by = df_aq_m$Date)
ts_b <- xts(df_aq_b$PM10, order.by = df_aq_b$Date)
ts_s <- xts(df_aq_s$PM10, order.by = df_aq_s$Date)
```
```{r fig.height=6, fig.width=10}
plot_3_ts(
  ts1 = ts_m, ts2 = ts_b, ts3 = ts_s,
  ts_colors = station_colors,
  main = "PM10 time series for the stations",
  ylab = paste("PM10 ", "(", pollutant_units[["PM10"]], ")", sep = ""),
  legend_names = aq_station_names_full
)
```
```{r fig.height=8, fig.width=10}
plot_ts_grid(
  ts_list = list(ts_m, ts_b, ts_s),
  ylab = paste("PM10 ", "(", pollutant_units[["PM10"]], ")", sep = ""),
  ts_colors = station_colors,
  n_row = 3,
  ts_names = aq_station_names_full
)
```
```{r}
ts_m <- xts2ts(ts_m, daily_ts_freq)
ts_b <- xts2ts(ts_b, daily_ts_freq)
ts_s <- xts2ts(ts_s, daily_ts_freq)
```

# Preprocessing
## Missing values imputation
Important to fill missing values when conisdering the daily data

"Length of time series" - Number of observations in the time series (including NAs)
"Number of Missing Values" - Number of missing values in the time series
"Number of Gaps" - Number of NA gaps (consisting of one or more consecutive NAs) in the time series
"Average Gap Size" - Average size of consecutive NAs for the NA gaps in the time series
"Percentage of Missing Values" - Percentage of missing values in the time series
"Longest NA gap" - Longest series of consecutive missing values (NAs in a row) in the time series
"Most frequent gap size" - Most frequent occurring series of missing values in the time series
```{r}
stats_na_ts_m <- imputeTS::statsNA(ts_m, print_only = FALSE)
stats_na_ts_b <- imputeTS::statsNA(ts_b, print_only = FALSE)
stats_na_ts_s <- imputeTS::statsNA(ts_s, print_only = FALSE)
stats_na_table <- as.data.frame(
  rbind(
    stats_na_ts_m,
    stats_na_ts_b,
    stats_na_ts_s
  )
)
stats_na_table <- stats_na_table[, c(-dim(stats_na_table)[2], -(dim(stats_na_table)[2] - 1))]
colnames(stats_na_table) <- c(
  "Length TS", "Number NAs", "Number Gaps", "Average Gap Size",
  "Percentage NAs", "Longest NA gap", "Most frequent gap size"
)
rownames(stats_na_table) <- aq_station_names_code
stats_na_table
```

```{r fig.height=4, fig.width=10}
imputeTS::ggplot_na_distribution2(ts_m,
  title = paste(aq_station_names_code[1], "-", "missing values ratio per interval"),
)
```
```{r fig.height=4, fig.width=10}
imputeTS::ggplot_na_distribution2(ts_b,
  title = paste(aq_station_names_code[2], "-", "missing values ratio per interval"),
)
```
```{r fig.height=4, fig.width=10}
imputeTS::ggplot_na_distribution2(ts_s,
  title = paste(aq_station_names_code[3], "-", "missing values ratio per interval"),
)
```

```{r fig.height=4, fig.width=8}
ts_m_imputed <- imputeTS::na_interpolation(ts_m)
ts_b_imputed <- imputeTS::na_interpolation(ts_b)
ts_s_imputed <- imputeTS::na_interpolation(ts_s)

imputeTS::ggplot_na_imputations(
  window_ts_xts(ts_m, df_aq_m$Date, "2021-01-01", "2022-12-31"),
  window_ts_xts(ts_m_imputed, df_aq_m$Date, "2021-01-01", "2022-12-31"),
  title = paste(aq_station_names_short[1], "-", "Linear imputation"),
  x_axis_labels = time(window_ts_xts(ts_m, df_aq_m$Date, "2021-01-01", "2022-12-31")),
  color_points = station_colors[1],
  color_lines = rgb2hex_custom(col2rgb_custom(station_colors[1], 0.6)),
  color_imputations = "red",
  ylab = paste("PM10 ", "(", pollutant_units[["PM10"]], ")", sep = "")
)
imputeTS::ggplot_na_imputations(
  window_ts_xts(ts_b, df_aq_b$Date, "2014-01-01", "2015-12-31"),
  window_ts_xts(ts_b_imputed, df_aq_b$Date, "2014-01-01", "2015-12-31"),
  title = paste(aq_station_names_short[2], "-", "Linear imputation"),
  x_axis_labels = time(window_ts_xts(ts_b, df_aq_b$Date, "2014-01-01", "2015-12-31")),
  color_points = station_colors[2],
  color_lines = rgb2hex_custom(col2rgb_custom(station_colors[2], 0.6)),
  color_imputations = "red",
  ylab = paste("PM10 ", "(", pollutant_units[["PM10"]], ")", sep = "")
)
imputeTS::ggplot_na_imputations(
  window_ts_xts(ts_s, df_aq_s$Date, "2016-01-01", "2017-12-31"),
  window_ts_xts(ts_s_imputed, df_aq_s$Date, "2016-01-01", "2017-12-31"),
  title = paste(aq_station_names_short[3], "-", "Linear imputation"),
  x_axis_labels = time(window_ts_xts(ts_s, df_aq_s$Date, "2016-01-01", "2017-12-31")),
  color_points = station_colors[3],
  color_lines = rgb2hex_custom(col2rgb_custom(station_colors[3], 0.6)),
  color_imputations = "red",
  ylab = paste("PM10 ", "(", pollutant_units[["PM10"]], ")", sep = "")
)
ts_m <- ts_m_imputed
ts_b <- ts_b_imputed
ts_s <- ts_s_imputed
df_aq_m$PM10 <- as.numeric(ts_m_imputed)
df_aq_b$PM10 <- as.numeric(ts_b_imputed)
df_aq_s$PM10 <- as.numeric(ts_s_imputed)
```
```{r}
print(
  paste(
    "Number of NA values in PM10 among the station are: ",
    sum(
      sum(is.na(df_aq_m$PM10)),
      sum(is.na(df_aq_m$PM10)),
      sum(is.na(df_aq_b$PM10))
    )
  )
)
```

## Outliers detection
```{r}
outliers_ts_m <- tsoutliers(ts_m)
outliers_ts_b <- tsoutliers(ts_b)
outliers_ts_s <- tsoutliers(ts_s)

tmp_ts_m <- ts(ts_m)
tmp_ts_m[outliers_ts_m$index] <- NA
imputeTS::ggplot_na_imputations(
  tmp_ts_m, ts_m,
  title = paste(aq_station_names_code[1], "-", "outliers detection"),
  x_axis_labels = date_range,
  color_lines = station_colors[1],
  color_imputations = "red",
  ylab = paste("PM10 ", "(", pollutant_units[["PM10"]], ")", sep = ""),
  size_points = NA,
  size_imputations = 3,
  legend = FALSE
)
tmp_ts_b <- ts(ts_b)
tmp_ts_b[outliers_ts_b$index] <- NA
imputeTS::ggplot_na_imputations(
  tmp_ts_b, ts_b,
  title = paste(aq_station_names_code[2], "-", "outliers detection"),
  x_axis_labels = date_range,
  color_lines = station_colors[2],
  color_imputations = "red",
  ylab = paste("PM10 ", "(", pollutant_units[["PM10"]], ")", sep = ""),
  size_points = NA,
  size_imputations = 3,
  legend = FALSE
)
tmp_ts_s <- ts(ts_s)
tmp_ts_s[outliers_ts_s$index] <- NA
imputeTS::ggplot_na_imputations(
  tmp_ts_s, ts_s,
  title = paste(aq_station_names_code[3], "-", "outliers detection"),
  x_axis_labels = date_range,
  color_lines = station_colors[3],
  color_imputations = "red",
  ylab = paste("PM10 ", "(", pollutant_units[["PM10"]], ")", sep = ""),
  size_points = NA,
  size_imputations = 3,
  legend = FALSE
)
outliers_ts_m <- NULL
outliers_ts_b <- NULL
outliers_ts_s <- NULL
tmp_ts_m <- NULL
tmp_ts_b <- NULL
tmp_ts_s <- NULL
```


# Time series data analysis
Data are aggregated by month so a long term analysis can be performed, as said
```{r}
agg_df_aq_m <- ARPALData::Time_aggregate(
  df_aq_m, "monthly",
  Var_vec = "PM10", Fns_vec = "mean"
)
agg_df_aq_b <- ARPALData::Time_aggregate(
  df_aq_b, "monthly",
  Var_vec = "PM10", Fns_vec = "mean"
)
agg_df_aq_s <- ARPALData::Time_aggregate(
  df_aq_s, "monthly",
  Var_vec = "PM10", Fns_vec = "mean"
)
ts_m_monthly <- xts(agg_df_aq_m$PM10, order.by = agg_df_aq_m$Date)
ts_b_monthly <- xts(agg_df_aq_b$PM10, order.by = agg_df_aq_b$Date)
ts_s_monthly <- xts(agg_df_aq_s$PM10, order.by = agg_df_aq_s$Date)

plot_ts_grid(
  ts_list = list(ts_m_monthly, ts_b_monthly, ts_s_monthly),
  ylab = paste("PM10 ", "(", pollutant_units[["PM10"]], ")", sep = ""),
  ts_colors = station_colors,
  n_row = 3,
  ts_names = aq_station_names_full
)

agg_df_aq_m <- NULL
agg_df_aq_b <- NULL
agg_df_aq_s <- NULL
ts_m_monthly <- xts2ts(ts_m_monthly, monthly_ts_freq)
ts_b_monthly <- xts2ts(ts_b_monthly, monthly_ts_freq)
ts_s_monthly <- xts2ts(ts_s_monthly, monthly_ts_freq)
```
The time series seems to be not stationary. However the time series tread and seasonality appears not clear

## Autocorrelation and partial autocorrelation
**Station 703 - Schivenoglia v. Malpasso**
```{r}
plot_acf_pacf(ts_m_monthly, aq_station_names_code[1])
```
**Station 571 - Bormio v.Monte Braulio**
```{r}
plot_acf_pacf(ts_b_monthly, aq_station_names_code[2])
```

**Station 703 - Schivenoglia v. Malpasso**
```{r}
plot_acf_pacf(ts_s_monthly, aq_station_names_code[3])
```

This is confirmed by ACF plot that exibit relevant obscillation. In particular it seems that among all the station there is a sinusoidal variation every 6 months. This is confirmed by the PACF plot that shows a significant peak at lag 6.

## Monthplot
The monthplot is a useful tool for visualizing the monthly pattern of a time series.

The graph confirms what was expected: the observations exhibit a strong monthly seasonality, generally showing an increase in the winter months and a decrease in the summer month.
```{r}
monthplot(
  ts_m_monthly,
  main = paste("Monthly plot of PM10 for", aq_station_names_short[1]),
  xlab = "Month",
  ylab = paste("PM10 ", "(", pollutant_units[["PM10"]], ")", sep = "")
)
monthplot(
  ts_b_monthly,
  main = paste("Monthly plot of PM10 for", aq_station_names_short[2]),
  xlab = "Month",
  ylab = paste("PM10 ", "(", pollutant_units[["PM10"]], ")", sep = "")
)
monthplot(
  ts_s_monthly,
  main = paste("Monthly plot of PM10 for", aq_station_names_short[3]),
  xlab = "Month",
  ylab = paste("PM10 ", "(", pollutant_units[["PM10"]], ")", sep = "")
)
```

## Smoothing and decomposition
Basic filter: the **simple moving average**, which calculates the arithmetic average over a time window $p$.

$$
\hat{f}_t = \frac{1}{2p + 1} \sum_{i=-p}^p y_{t+i}
$$

Different values of $p$ are tested and they play a significant role in determining the effect of smoothing because larger values of $p$ result in a smoother trend estimate.


s.window controls how rapidly the seasonal component can change. Small values allow more rapid change. Setting the seasonal window to be infinite is equivalent to forcing the seasonal component to be periodic

If you think the seasonal pattern is constant through time, you should set this parameter to a big value, so that you use the entire data to perform your analysis. If on the other way round, the seasonal pattern evolves quickly, reduce this parameter to use only the recent data so that your analysis is not affected by old seasonal pattern that are not relevant anymore
```{r}
plot_filtered_ts(
  original_ts = ts_m_monthly,
  filtered_ts_list = list(simple_ma(ts_m_monthly, p = 4), simple_ma(ts_m_monthly, p = 8), simple_ma(ts_m_monthly, p = 12)),
  main = paste(aq_station_names_code[1], "-", "simple moving average filter"),
  ylab = paste("PM10 ", "(", pollutant_units[["PM10"]], ")", sep = ""),
  legend_names = c("p = 4", "p = 8", "p = 12"),
  line_colors = filtering_colors
)
plot_filtered_ts(
  original_ts = ts_b_monthly,
  filtered_ts_list = list(simple_ma(ts_b_monthly, p = 4), simple_ma(ts_b_monthly, p = 8), simple_ma(ts_b_monthly, p = 12)),
  main = paste(aq_station_names_code[2], "-", "simple moving average filter"),
  ylab = paste("PM10 ", "(", pollutant_units[["PM10"]], ")", sep = ""),
  legend_names = c("p = 4", "p = 8", "p = 12"),
  line_colors = filtering_colors
)
plot_filtered_ts(
  original_ts = ts_s_monthly,
  filtered_ts_list = list(simple_ma(ts_s_monthly, p = 4), simple_ma(ts_s_monthly, p = 8), simple_ma(ts_s_monthly, p = 12)),
  main = paste(aq_station_names_code[3], "-", "simple moving average filter"),
  ylab = paste("PM10 ", "(", pollutant_units[["PM10"]], ")", sep = ""),
  legend_names = c("p = 4", "p = 8", "p = 12"),
  line_colors = filtering_colors
)
```
```{r}
plot_filtered_ts(
  original_ts = ts_m_monthly,
  filtered_ts_list = list(ma_for_seasonal(ts_m_monthly, monthly_ts_freq)),
  main = paste(aq_station_names_code[1], "-", "moving average for seasonal data"),
  ylab = paste("PM10 ", "(", pollutant_units[["PM10"]], ")", sep = ""),
  legend_names = c("MA seasonal"),
  line_colors = filtering_colors
)
plot_filtered_ts(
  original_ts = ts_b_monthly,
  filtered_ts_list = list(ma_for_seasonal(ts_b_monthly, monthly_ts_freq)),
  main = paste(aq_station_names_code[2], "-", "moving average for seasonal data"),
  ylab = paste("PM10 ", "(", pollutant_units[["PM10"]], ")", sep = ""),
  legend_names = c("MA seasonal"),
  line_colors = filtering_colors
)
plot_filtered_ts(
  original_ts = ts_s_monthly,
  filtered_ts_list = list(ma_for_seasonal(ts_s_monthly, monthly_ts_freq)),
  main = paste(aq_station_names_code[3], "-", "moving average for seasonal data"),
  ylab = paste("PM10 ", "(", pollutant_units[["PM10"]], ")", sep = ""),
  legend_names = c("MA seasonal"),
  line_colors = filtering_colors
)
```


```{r}
stl_ts_m_monthly <- stl(ts_m_monthly, s.window = "periodic", robust = TRUE)
stl_ts_b_monthly <- stl(ts_b_monthly, s.window = "periodic", robust = TRUE)
stl_ts_s_monthly <- stl(ts_s_monthly, s.window = "periodic", robust = TRUE)
plot(
  stl_ts_m_monthly,
  main = paste(aq_station_names_code[1], "-", "PM10 - STL decomposition")
)
plot(
  stl_ts_b_monthly,
  main = paste(aq_station_names_code[2], "-", "PM10 - STL decomposition")
)
plot(
  stl_ts_s_monthly,
  main = paste(aq_station_names_code[3], "-", "PM10 - STL decomposition")
)
```

```{r}
ljung_box_noise_ts_m <- Box.test(stl_ts_m_monthly$time.series[, "remainder"], type = "Ljung-Box")$p.value
ljung_box_noise_ts_b <- Box.test(stl_ts_b_monthly$time.series[, "remainder"], type = "Ljung-Box")$p.value
ljung_box_noise_ts_s <- Box.test(stl_ts_s_monthly$time.series[, "remainder"], type = "Ljung-Box")$p.value
ljung_box_noise <- data.frame(
  p_value = c(ljung_box_noise_ts_m, ljung_box_noise_ts_b, ljung_box_noise_ts_s)
)
rownames(ljung_box_noise) <- aq_station_names_code
colnames(ljung_box_noise) <- "p-value"
print_table_custom(ljung_box_noise, title = "Ljung-Box test for the noise component")

stl_ts_m_monthly <- NULL
stl_ts_b_monthly <- NULL
stl_ts_s_monthly <- NULL
ljung_box_noise_ts_m <- NULL
ljung_box_noise_ts_b <- NULL
ljung_box_noise_ts_s <- NULL
ljung_box_noise <- NULL
```
Decompositions seems white noise by statistical hypotesis test.


# Models developement
Now daily data are used, as anticipated

## ARIMA models implementation
```{r}
start_window <- "2022-01-01"
end_window <- end_date
start_window <- as.Date(start_window)
end_window <- as.Date(end_window)

# Train-test split
test_set_size <- 30
train_set_start <- start_window
train_set_end <- as.Date(end_window) - test_set_size - 1
test_set_start <- train_set_end + 1
test_set_end <- end_window
date_range_train <- seq(train_set_start, train_set_end, by = "day")
date_range_test <- seq(test_set_start, test_set_end, by = "day")
```
**Station 703 - Schivenoglia v. Malpasso**
```{r}
ts_m_train <- window_ts_xts(ts_m, df_aq_m$Date, train_set_start, train_set_end)
plot_single_ts(ts_m_train,
  ts_name = aq_station_names_code[1],
  ts_color = station_colors[1],
  ylab = paste("PM10", pollutant_units[["PM10"]])
)
plot_different_acf_pacf(ts_m_train, aq_station_names_code[1], max_lag = 40)
ts_m_train <- xts2ts(ts_m_train, daily_ts_freq)
auto_ts_m <- auto.arima(ts_m_train, ic = "aic")
checkresiduals(auto_ts_m)
```

**Station 571 - Bormio v.Monte Braulio**
```{r}
ts_b_train <- window_ts_xts(ts_b, df_aq_b$Date, train_set_start, train_set_end)
plot_single_ts(ts_b_train,
  ts_name = aq_station_names_code[2],
  ts_color = station_colors[2],
  ylab = paste("PM10", pollutant_units[["PM10"]])
)
plot_different_acf_pacf(ts_b_train, aq_station_names_code[2], max_lag = 40)
ts_b_train <- xts2ts(ts_b_train, daily_ts_freq)
auto_ts_b <- auto.arima(ts_b_train, ic = "aic")
checkresiduals(auto_ts_b)
```

**Station 703 - Schivenoglia v. Malpasso**
```{r}
ts_s_train <- window_ts_xts(ts_s, df_aq_s$Date, train_set_start, train_set_end)
plot_single_ts(ts_s_train,
  ts_name = aq_station_names_code[3],
  ts_color = station_colors[3],
  ylab = paste("PM10", pollutant_units[["PM10"]])
)
plot_different_acf_pacf(ts_s_train, aq_station_names_code[3], max_lag = 40)
ts_s_train <- xts2ts(ts_s_train, daily_ts_freq)
auto_ts_s <- auto.arima(ts_s_train, ic = "aic")
checkresiduals(auto_ts_s)
```

```{r}
# thetahat_i/SE(thetahat_i) =t_i can be used for significance test of the parameter theta_i
# H0: theta_i=0
# HA: theta_i!=0
# if |t_i| is small -> H0
# if |t_i| is large -> HA

# SIMPLE RULE FOR CHECKING THE SIGNIFICANCE:
# n large, if H0 is true t_i behaves like N(0,1)
# So if |t_i|< 2 (2 is similar to 1.96, and 1.96 is the normal distrib quantile 0.975)
#--> Accept H0 if |t_i|<=2
#--> Reject H0 if |t_i|>2

# FOR DOING IT AUTOMATICALLY:
# abs(ring.fit$coef/sqrt(diag(ring.fit$var.coef))) >2
# tsdiag(lake.fit)
# checkresiduals(lake.fit)
# fitdf<-length(fit$coef)
# Box.test(residuals(lake.fit), lag=10, fitdf=fitdf, type="Ljung")
```

## Station correlations
```{r}
# Correlation Analysis:
# Investigate the relationships between air pollutants and meteorological variables.
# Identify key factors that may contribute to poor air quality in the region.
pw <- TSA::prewhiten(diff(ts_m_train), ts_b_train, plot = FALSE)$ccf
# w <- prewhitening(ts_s_train, list(ar = auto_ts_s$model$phi, ma = auto_ts_s$model$theta))

plot(ts_b_train ~ ts_m_train)

plot_ccf_prewhiten(pw, frequency = daily_ts_freq)
plot_ccf(u1, v1, paste(aq_station_names_code[1], "-", aq_station_names_code[2]), max_lag = 30)
# plot_ccf(u1, w1, paste(aq_station_names_code[1], "-", aq_station_names_code[3]))
# plot_ccf(v, w, paste(aq_station_names_code[2], "-", aq_station_names_code[3]))


a <- xts(df_aq_m$NO2, order.by = df_aq_m$Date)
a <- xts2ts(a, daily_ts_freq)
a <- imputeTS::na_interpolation(a)
Acf(a)
Pacf(a)


ts_no2_m_train <- window_ts_xts(a, df_aq_s$Date, train_set_start, train_set_end)
ts_no2_m_train <- xts2ts(ts_no2_m_train, daily_ts_freq)
plot(ts_m_train ~ ts_no2_m_train)
m <- lm(df_aq_m$PM10 ~ df_aq_m$NO2)
r <- resid(m)
Acf(r)
auto.arima(ts_no2_m_train, ic = "aic")

auto.arima(ts_m_train, xreg = ts_no2_m_train, ic = "aic")
```

## Dynamic regression
```{r}
# fit.y <- Arima(y, order = c(1, 0, 0))
# model.y <- list(ar = fit.y$model$phi, ma = fit.y$model$theta)
# u <- prewhitening(y, model.y)
# fit.x <- Arima(x, order = c(1, 0, 0))
# model.x <- list(ar = fit.x$model$phi, ma = fit.x$model$theta)
# v <- prewhitening(x, model.x)
# ccf(u, v, col = 4)
# grid()
```
```{r}
# try standart lin regr and multivariate TS analysis

# Correlation Analysis:
# Investigate the relationships between air pollutants and meteorological variables.
# Identify key factors that may contribute to poor air quality in the region.
```

## Non linear models
```{r}
fit <- nnetar(ts_m_train)
r <- as.numeric(resid(fit))
Acf(r, na.action = na.pass)
Box.test(r, type = "Ljung-Box") # residuals seems white noise
Acf(r^2, na.action = na.pass)
Box.test(r^2, type = "Ljung-Box")

Ccf(as.numeric(ts_m_train), r, na.action = na.pass)
Ccf(as.numeric(ts_m_train)^2, r, na.action = na.pass)
Ccf((r * as.numeric(ts_m_train)^2), r, na.action = na.pass)
```
```{r}
## For checking some threshold models
# lag1.plot(dflu, corr = FALSE, col = 4, pch = 20)
#
## Neural Network Autoregressive Model
# fit <- nnetar(y, p = 9, size = 5)
## Y_t=f(Y_{t-1}, ..., Y_{t-9})+Z_t where Z_t is WN(0, sigma^2) independent
## f(Y_{t-1}, ..., Y_{t-9}) is a NN with K=5 (5 hidden unit)
# r <- as.numeric(resid(fit))
# acf(r, na.action = na.pass)
# Box.test(r, type = "Ljung-Box") # residuals seems white noise
# acf(r^2, na.action = na.pass)
# Box.test(r^2, type = "Ljung-Box") # residuals seems white noise also if they are ^2 (check is some non lin pattern is resid^2)
# plot(forecast(fit, h = 20, times = 10, PI = TRUE, bootstrap = FALSE))
## bootstrap = FALSE: pick randomly the value e_t from Gaussian
## bootstrap=TRUE: pick error from past observation
## This is needed for the forecasting Y_t=f(X_t)+e_t
# Watt <- APTelectric[, 1]
# fit <- nnetar(Watt) # Model that use only the information coming from TS Y_t
## param p is automatically derived here because it's not specified
# nnetforecast <- forecast(fit, h = 400, PI = FALSE)
# plot(nnetforecast)
# Appliances <- as.numeric(APTelectric[, 2])
#
# fit2 <- nnetar(Watt, xreg = Appliances) # Model that use also the info of the second TS
# print(fit2)
# r <- as.numeric(resid(fit2))
# acf(r, na.action = na.pass)
# Box.test(r, type = "Ljung-Box")
# acf(r^2, na.action = na.pass)
# Box.test(r^2, type = "Ljung-Box")
#
## Check also other relations in the residuals
# par(mfrow = c(2, 2))
# ccf(Appliances, r, na.action = na.pass)
# ccf(Appliances^2, r, na.action = na.pass)
# ccf((r * Appliances^2), r, na.action = na.pass)
```
# Forecasting
```{r}
# Compare models with metrics and with "simpler" forecasting models
```
"Ammonia"        "Arsenic"        "Benzene"        "Benzo_a_pyrene" "BlackCarbon"   
"Cadmium"        "CO"             "Lead"           "Nikel"          "NO2"            "NOx"            "Ozone"          "PM_tot"        
"PM10"           "PM2.5"          "Sulfur_dioxide"


# Conclusions
```{r}
# Discussion and further perspectives.
# The discussion section should recall the main results and point to new research questions, that appeared from your work, or possible limitations.
```


